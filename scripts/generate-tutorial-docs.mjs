#!/usr/bin/env node
import { join, resolve, dirname } from 'path';
import { readdirSync, readFileSync, rmSync, writeFileSync } from 'fs';
import { valid, lte, rcompare, prerelease, major, minor, patch } from 'semver';
import { glob } from 'glob';

import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT = resolve(__dirname, '..');

function camelCaseToSentenceCase(str) {
  const tmp = str.replace(/([A-Z])/g, ' $1');

  return tmp.charAt(0).toUpperCase() + tmp.slice(1);
}

function camelCaseToSnakeCase(str) {
  return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}

async function go() {
  // Find all pixi-version.json files
  const versionFiles = glob.sync(`${ROOT}/**/pixi-version.json`);
  const TUTORIALS_PATH = resolve(ROOT, 'src', 'tutorials');

  // Read the directories in the tutorials directory
  const tutorialDirectories = readdirSync(TUTORIALS_PATH, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  // Perform the script on all the directories that they are in
  for (const versionFile of versionFiles) {
    const DOCS_PATH = dirname(versionFile);
    const TUTORIALS_MD_PATH = resolve(DOCS_PATH, 'tutorials');
    const pixiVersion = JSON.parse(readFileSync(versionFile, 'utf8'));
    const VERSION = pixiVersion.version;
    const isPrerelease = prerelease(`v${VERSION}`);
    const versionToCompare = isPrerelease ? `v${major(VERSION)}.${minor(VERSION)}.${patch(VERSION)}` : `v${VERSION}`;

    // Filter and sort the directories to find the best match
    const bestMatch = tutorialDirectories

      .filter((name) => valid(name) && lte(name, versionToCompare))
      .sort((a, b) => rcompare(a, b))[0];

    console.log(`Generating tutorials for v${VERSION} using the ${bestMatch} source`);

    const TUTORIALS_JS_PATH = resolve(TUTORIALS_PATH, bestMatch);

    const tutorialsData = JSON.parse(readFileSync(`${TUTORIALS_JS_PATH}/tutorialsData.json`, 'utf8'));

    const fileData = tutorialsData.map((tutorialKey) => {
      const mdName = camelCaseToSnakeCase(tutorialKey);
      const title = camelCaseToSentenceCase(tutorialKey);

      return {
        tutorialKey,
        title,
        filePath: `${join(TUTORIALS_MD_PATH, mdName)}.md`,
      };
    });

    // delete old stuff first
    readdirSync(TUTORIALS_MD_PATH, (err, files) => {
      if (err) throw err;

      for (const file of files) {
        // Keep index.md
        if (file === 'index.md' || file === '.gitignore') continue;
        rmSync(join(TUTORIALS_MD_PATH, file), { recursive: true, force: true });
      }
    });

    fileData.forEach(({ tutorialKey, filePath }) => {
      const mdContents = [
        '---',
        'hide_title: true',
        'pagination_next: null',
        'pagination_prev: null',
        'custom_edit_url: null',
        '---',
        '<!-- AUTO-GENERATED BY [generate-tutorial-docs] script -->',
        "import Tutorial from '@site/src/components/Tutorial/index';",
        "import version from '../pixi-version.json';",
        '',
        `<Tutorial id="${tutorialKey}" pixiVersion={version}/>`,
        '',
      ].join('\n');

      writeFileSync(filePath, mdContents, 'utf8');
    });
  }
}

go();
